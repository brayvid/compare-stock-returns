<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" integrity="sha512-qveKnGrvOChbSzAdtSs8p69eoLegyh+1hwOMbmpCViIwj7rn4oJjdmMvWOuyQlTOZgTlZA0N2PXA7iA8/2TUYA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <title>Compare Stock Returns</title>
    <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">

    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0; 
            padding: 0; 
            background-color: #f0f2f6; 
            line-height: 1.6;
        }
        .page-wrapper { /* New overall wrapper for content */
            padding: 15px;
            max-width: 1200px; /* Optional: constrain max width on very large screens */
            margin: 0 auto; /* Center content */
        }
        /* Form now acts as the main layout container for controls + plot */
        .content-form {
            display: flex;
            flex-direction: column; /* Stack controls and plot area vertically */
        }

        .controls-area { /* Container for all input controls */
            background-color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }
        .controls-area h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.4em;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .control-group { /* Group related controls, e.g., symbols + benchmark */
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Responsive grid */
            gap: 15px;
            margin-bottom: 15px;
        }
        .control-group > div { /* Each individual control wrapper */
            display: flex;
            flex-direction: column;
        }
        label { 
            margin-bottom: 5px; 
            font-weight: 600; 
            font-size: 0.9em;
            color: #444;
        }
        input[type="text"], 
        input[type="date"],
        select { /* Added select for consistency if used */
            width: 100%; /* Full width of its container */
            padding: 10px; 
            border: 1px solid #ccc; 
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.95em;
        }
        input[type="checkbox"] { margin-right: 8px; vertical-align: middle; width: auto;}
        .checkbox-label { display: inline; font-weight: normal; font-size: 0.95em; }

        .fine-tune-slider-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .fine-tune-slider-container h3 {
            margin-top:0;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #333;
        }
        #date-slider {
            margin: 10px 5px; /* Add some horizontal margin for handles */
        }
        .date-readouts { 
            display: flex; 
            justify-content: space-between; 
            margin-top: 8px; 
            font-size: 0.9em; 
            color: #555; 
        }
        .date-readouts span {
            background-color: #e9ecef;
            padding: 3px 8px;
            border-radius: 3px;
        }

        button[type="submit"] { 
            background-color: #007bff; 
            color: white; 
            padding: 12px 20px; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
            font-size: 1em; 
            font-weight: 500;
            width: 100%; /* Full width on mobile */
            max-width: 250px; /* Max width on larger screens */
            display: block; /* To allow margin auto for centering if not full width */
            margin: 20px auto 0 auto; /* Center the button */
        }
        button[type="submit"]:hover { background-color: #0056b3; }

        .plot-messages-area { /* Container for plot and messages */
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        }
        .plot-messages-area h1 { display:none; /* Hide if title is in controls */ }

        .plot-container img { 
            max-width: 100%; 
            height: auto; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
            margin-top: 10px; /* Space from messages/error */
            display: block; /* Ensure it behaves like a block */
        }
        
        .messages-container { 
            margin-top: 15px; 
            max-height: 150px; /* Shorter height for messages */
            overflow-y: auto; 
            border: 1px solid #eee; 
            padding:10px; 
            background: #f9f9f9; 
            border-radius: 4px;
            font-size: 0.85em;
        }
        .message { padding: 8px; margin-bottom:8px; border-radius: 4px; }
        .message.error-main { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; font-weight: bold; }
        .message.info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb;}
        .message.warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba;}
        .message.detail-error { background-color: #fce8e6; color: #c92100; border: 1px solid #f5c6cb; opacity: 0.9;}

        /* noUiSlider Customizations */
        .noUi-connect { background: #007bff; }
        .noUi-handle { border: 1px solid #D9D9D9; border-radius: 3px; background: #FFF; box-shadow: inset 0 0 1px #FFF, inset 0 1px 7px #EBEBEB, 0 3px 6px -3px #BBB; }
        .noUi-target { border-color: #ddd; }


        /* Responsive adjustments - Desktop first approach can be easier sometimes, but here's mobile-first idea */
        /* Default: single column for all up to a breakpoint */
        /* .content-form, .controls-area, .plot-messages-area are already block/column by default */
        
        /* For larger screens, re-introduce sidebar or multi-column layouts if desired */
        /* For this request, we keep it single column always and just refine grid */
        /* Example of how a sidebar could be re-introduced on larger screens:
        @media (min-width: 769px) {
            .content-form {
                flex-direction: row; // Put sidebar and main content side-by-side
                gap: 20px;
            }
            .controls-area { // This would be the "sidebar"
                width: 300px;
                flex-shrink: 0;
                margin-bottom: 0; // No bottom margin when side-by-side
                height: calc(100vh - 30px); // Example height
                overflow-y: auto;
            }
            .plot-messages-area { // This would be the "main content"
                flex-grow: 1;
            }
            button[type="submit"] {
                width: auto; // Button not full width in sidebar
                margin: 20px 0 0 0;
            }
        }
        */

        .main-page-title { /* Style for the main title */
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.2em; /* Default size for larger screens */
            font-weight: 600; /* Example font weight */
        }

        /* --- Responsive adjustments --- */
        
        /* For mobile devices (e.g., screens less than 768px wide) */
        @media (max-width: 768px) {
            .main-page-title {
                font-size: 1.6em; /* Smaller font size for mobile */
                margin-bottom: 15px; /* Adjust margin if needed */
            }

            .controls-area h2 { /* Example: also adjust controls area title */
                font-size: 1.2em;
            }

            /* You can add other mobile-specific styles here */
            input[type="text"], 
            input[type="date"],
            select {
                padding: 8px; /* Slightly smaller padding on mobile inputs */
                font-size: 0.9em;
            }
             button[type="submit"] {
                padding: 10px 15px;
                font-size: 0.95em;
            }
            .fine-tune-slider-container h3 {
                font-size: 1em;
            }
        }

        /* Optional: Even smaller screens */
        @media (max-width: 480px) {
            .main-page-title {
                font-size: 1.4em; /* Even smaller for very small screens */
            }
             .controls-area h2 {
                font-size: 1.1em;
            }
        }

    </style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZXGDGE5KVR"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-ZXGDGE5KVR');
    </script>

</head>
<body>
    <div class="page-wrapper">
        <h1 class="main-page-title" style="text-align: center; color: #333; margin-bottom: 20px;">Compare Stock Returns</h1>
        <p style="text-align:center; font-size: 0.9em" class="author"><a href="https://github.com/brayvid/stock-returns" target="_blank">View on GitHub</a></p>

        <form method="GET" action="/" class="content-form">
            <div class="controls-area">
                <h2>Chart Controls</h2>
                
                <div class="control-group">
                    <div>
                        <label for="symbols">Stock Symbols (comma-separated):</label>
                        <input type="text" id="symbols" name="symbols" value="{{ inputs.symbols }}">
                    </div>
                    <div>
                        <label for="benchmark">Benchmark Symbol:</label>
                        <input type="text" id="benchmark" name="benchmark" value="{{ inputs.benchmark }}">
                    </div>
                </div>

                <div class="control-group">
                    <div>
                        <label for="start_date">Start Date:</label>
                        <input type="date" id="start_date" name="start_date" value="{{ inputs.start_date }}">
                    </div>
                    <div>
                        <label for="end_date">End Date:</label>
                        <input type="date" id="end_date" name="end_date" value="{{ inputs.end_date }}">
                    </div>
                </div>
                
                <div> <!-- Checkbox group, not in grid directly for simpler layout -->
                    <input type="checkbox" id="log_scale" name="log_scale" value="true" {% if inputs.log_scale %}checked{% endif %}>
                    <label for="log_scale" class="checkbox-label">Logarithmic Scale</label>
                </div>

                {% if min_data_date_str and max_data_date_str %}
                <div class="fine-tune-slider-container">
                    <h3>Fine-tune Dates:</h3>
                    <div id="date-slider"></div>
                    <div class="date-readouts">
                        <span id="slider-start-date-readout">Loading...</span>
                        <span id="slider-end-date-readout">Loading...</span>
                    </div>
                    <!-- Hidden inputs to store slider values for form submission -->
                    <input type="hidden" id="fine_tune_start_hidden" name="fine_tune_start" value="{{ inputs.fine_tune_start }}">
                    <input type="hidden" id="fine_tune_end_hidden" name="fine_tune_end" value="{{ inputs.fine_tune_end }}">
                </div>
                {% else %}
                <div class="fine-tune-slider-container">
                     <p style="font-size:0.9em; color:#777;"><em>Fine-tune range slider will appear after initial data is loaded.</em></p>
                </div>
                {% endif %}
                
                <button type="submit">Update Plot</button>
            </div>

            <div class="plot-messages-area">
                {% if error %}
                    <div class="message error-main">{{ error }}</div>
                {% endif %}
                
                {% if messages %}
                <div class="messages-container">
                    <h3 style="margin-top:0; font-size:1em; color:#333;">Processing Details:</h3>
                    {% for msg in messages %}
                        {% if "⚠️" in msg or "warning" in msg.lower() %}
                        <div class="message warning">{{ msg }}</div>
                        {% elif ("error" in msg.lower() or "no valid data" in msg.lower() or "empty" in msg.lower() or "failed" in msg.lower() or "cannot" in msg.lower()) and msg != error %}
                        <div class="message detail-error">{{ msg }}</div>
                        {% elif msg != error %}
                        <div class="message info">{{ msg }}</div>
                        {% endif %}
                    {% endfor %}
                </div>
                {% endif %}

                {% if plot_url %}
                    <div class="plot-container">
                        <img src="{{ plot_url }}" alt="Stock Returns Plot">
                    </div>
                {% elif not error and not messages and request.args and not plot_url %} 
                     <div class="message warning" style="margin-top:15px;">No plot generated. Check parameters and processing details.</div>
                {% elif not request.args %}
                    <div class="message info" style="margin-top:15px;">Configure options and click "Update Plot" to see results.</div>
                {% endif %}
            </div>
        </form>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js" integrity="sha512-UOJe4paV6hYWBnS0c9GnIRH8PLm2nFK22uhfAvsTIqd3uwnWsVri1OPn5fJYdLtGY3wB11LGHJ4yPU1WFJeBYQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            const dateSliderElement = document.getElementById('date-slider');
            const startDateReadout = document.getElementById('slider-start-date-readout');
            const endDateReadout = document.getElementById('slider-end-date-readout');
            const hiddenFineTuneStart = document.getElementById('fine_tune_start_hidden');
            const hiddenFineTuneEnd = document.getElementById('fine_tune_end_hidden');

            const minDataDateStr = "{{ min_data_date_str }}";
            const maxDataDateStr = "{{ max_data_date_str }}";
            let currentFineTuneStartStr = "{{ inputs.fine_tune_start }}";
            let currentFineTuneEndStr = "{{ inputs.fine_tune_end }}";

            // --- Initial logging of values from Flask ---
            console.log("Flask minDataDateStr:", minDataDateStr);
            console.log("Flask maxDataDateStr:", maxDataDateStr);
            console.log("Flask inputs.fine_tune_start:", currentFineTuneStartStr);
            console.log("Flask inputs.fine_tune_end:", currentFineTuneEndStr);

            if (!dateSliderElement || !minDataDateStr || !maxDataDateStr || minDataDateStr === "None" || maxDataDateStr === "None") {
                if(startDateReadout) startDateReadout.textContent = 'Range N/A';
                if(endDateReadout) endDateReadout.textContent = 'Range N/A';
                console.warn("Slider not initialized: HTML element missing, or min/max data dates are not available from Flask.", 
                             "minDataDateStr:", minDataDateStr, "maxDataDateStr:", maxDataDateStr);
                return;
            }
            
            // Fallback if fine_tune dates are missing from Flask (shouldn't happen if app.py is correct)
            if (!currentFineTuneStartStr || currentFineTuneStartStr === "None") {
                currentFineTuneStartStr = minDataDateStr;
                console.log("Fell back: currentFineTuneStartStr to minDataDateStr:", currentFineTuneStartStr);
            }
            if (!currentFineTuneEndStr || currentFineTuneEndStr === "None") {
                currentFineTuneEndStr = maxDataDateStr;
                console.log("Fell back: currentFineTuneEndStr to maxDataDateStr:", currentFineTuneEndStr);
            }


            // --- Utility functions ---
            function dateToTimestamp(dateInput) { // Renamed dateStr to dateInput for clarity
                console.log('[dateToTimestamp CALLED] Input:', dateInput, 'Type:', typeof dateInput);

                if (typeof dateInput === 'number') {
                    // If it's already a number, assume it's a timestamp.
                    // This is a defensive catch if it's called incorrectly.
                    console.warn("[dateToTimestamp WARN] Received a number, assuming it's a timestamp:", dateInput);
                    return dateInput; 
                }

                if (!dateInput || typeof dateInput !== 'string') {
                    console.error("dateToTimestamp: Invalid dateInput or not a string", dateInput);
                    return NaN;
                }
                // Now, dateInput is definitely a string
                const parts = dateInput.split('-');
                if (parts.length === 3) {
                    const year = parseInt(parts[0]);
                    const month = parseInt(parts[1]) - 1; // JS months are 0-indexed
                    const day = parseInt(parts[2]);
                    if (isNaN(year) || isNaN(month) || isNaN(day)) {
                        console.error("dateToTimestamp: Invalid date components after parsing", dateInput, parts);
                        return NaN;
                    }
                    return Date.UTC(year, month, day);
                }
                console.error("dateToTimestamp: dateInput string not in YYYY-MM-DD format", dateInput);
                // Avoid new Date(non_standard_string).getTime() as it's unreliable
                return NaN; 
            }

            function timestampToDate(timestamp) {
                if (isNaN(timestamp) || timestamp === null || timestamp === undefined) {
                    console.error("timestampToDate: Invalid timestamp input", timestamp);
                    return "NaN-aN-aN"; // Explicitly return this on error
                }
                const date = new Date(timestamp);
                const year = date.getUTCFullYear();
                const month = ('0' + (date.getUTCMonth() + 1)).slice(-2);
                const day = ('0' + date.getUTCDate()).slice(-2);
                const formattedDate = `${year}-${month}-${day}`;
                // console.log("timestampToDate:", timestamp, "->", formattedDate);
                return formattedDate;
            }
            
            let minTs = dateToTimestamp(minDataDateStr);
            let maxTs = dateToTimestamp(maxDataDateStr);
            let startTs = dateToTimestamp(currentFineTuneStartStr);
            let endTs = dateToTimestamp(currentFineTuneEndStr);

            // --- Logging of initial timestamps ---
            console.log("Initial Timestamps: minTs:", minTs, "maxTs:", maxTs, "startTs:", startTs, "endTs:", endTs);

            if (isNaN(minTs) || isNaN(maxTs)) {
                if(startDateReadout) startDateReadout.textContent = 'Error';
                if(endDateReadout) endDateReadout.textContent = 'Error';
                console.error("Slider initialization failed: minTs or maxTs is NaN.", 
                               "MinDate:", minDataDateStr, "MaxDate:", maxDataDateStr);
                return;
            }
            if (minTs > maxTs) { // If min is somehow after max (data issue or parsing)
                console.warn("minTs is greater than maxTs. Swapping them for slider range.", minTs, maxTs);
                [minTs, maxTs] = [maxTs, minTs]; // Swap them
            }
             if (minTs === maxTs) { // If only one day of data
                console.warn("minTs equals maxTs. Slider will represent a single day. Adjusting step or disabling may be needed if problematic.");
                // noUiSlider might need maxTs to be slightly larger than minTs for a range.
                // For a single day, a slider isn't ideal, but let's try to make it work.
                // If you must have a range, make maxTs one day after minTs, but this might not reflect actual data.
                // For now, we let it be, but tooltips might be very close.
                // maxTs = minTs + (24 * 60 * 60 * 1000); // Option: make it a one-day range
            }


            // Before noUiSlider.create, after minTs and maxTs are defined:
            let effectiveMaxTs = (maxTs <= minTs) ? (minTs + (24*60*60*1000 -1)) : maxTs;

            // Ensure initial slider start/end values are within the overall min/max range
            startTs = Math.max(minTs, Math.min(startTs, effectiveMaxTs)); // Use effectiveMaxTs
            endTs = Math.min(effectiveMaxTs, Math.max(endTs, minTs));     // Use effectiveMaxTs
            if (startTs > endTs && minTs < effectiveMaxTs) {
                console.warn("startTs > endTs after clamping, swapping. startTs:", startTs, "endTs:", endTs);
                [startTs, endTs] = [endTs, startTs];
            } else if (startTs > endTs && minTs === effectiveMaxTs) { 
                endTs = startTs;
            } else if (isNaN(startTs)){
                startTs = minTs;
            } else if (isNaN(endTs)){
                endTs = effectiveMaxTs; // Use effectiveMaxTs
            }


            // Update current fine tune strings and hidden inputs based on potentially clamped/corrected timestamps
            currentFineTuneStartStr = timestampToDate(startTs);
            currentFineTuneEndStr = timestampToDate(endTs);
            if (hiddenFineTuneStart) hiddenFineTuneStart.value = currentFineTuneStartStr;
            if (hiddenFineTuneEnd) hiddenFineTuneEnd.value = currentFineTuneEndStr;

            // --- Logging of clamped/final timestamps for slider ---
            console.log("Clamped Timestamps for Slider: startTs:", startTs, "endTs:", endTs);
            console.log("Corresponding Dates: start:", currentFineTuneStartStr, "end:", currentFineTuneEndStr);


            noUiSlider.create(dateSliderElement, {
                // In noUiSlider.create options:
                range: {
                    'min': minTs,
                    'max': (maxTs <= minTs) ? (minTs + (24*60*60*1000 -1)) : maxTs 
                    // Ensure max is always > min for slider creation.
                    // If original maxTs <= minTs, create a tiny range.
                },
                start: [startTs, endTs], // These are numbers (timestamps)
                connect: true,
                step: 24 * 60 * 60 * 1000, 
                tooltips: false, // Explicitly false
                behaviour: 'tap-drag',
                format: {
                    // `to` takes the slider's internal numeric value (timestamp) and converts it to a string for display/output
                    to: function (value) { 
                        // console.log('[format.to CALLED] Input (slider internal value):', value, 'Type:', typeof value);
                        return timestampToDate(Number(value)); // Ensure value is treated as number
                    },
                    // `from` takes an external string value OR the initial numeric start values
                    // and converts it to the slider's internal numeric value (timestamp)
                    from: function (value) { 
                        console.log('[format.from CALLED] Input (value to convert to slider internal):', value, 'Type:', typeof value);
                        if (typeof value === 'string') {
                            // Check if the string is a number (i.e., a stringified timestamp)
                            // or if it contains hyphens (i.e., a "YYYY-MM-DD" date string)
                            if (value.includes('-')) { 
                                // It's a "YYYY-MM-DD" string
                                return dateToTimestamp(value);
                            } else {
                                // It's likely a stringified timestamp, e.g., "1591056000000"
                                // Convert it to a number first.
                                const numericValue = parseFloat(value);
                                if (!isNaN(numericValue)) {
                                    console.log('[format.from INFO] Detected stringified timestamp, returning as number:', numericValue);
                                    return numericValue; // Return the number (timestamp)
                                } else {
                                    console.error('[format.from ERROR] String value is not YYYY-MM-DD and not a parseable number:', value);
                                    return dateToTimestamp(value); // Let dateToTimestamp handle it and likely return NaN with an error
                                }
                            }
                        } else if (typeof value === 'number') {
                            // This handles if noUiSlider ever passes a direct number (e.g. from internal calculations)
                            return value; 
                        }
                        // Fallback for unexpected types
                        console.error("[format.from ERROR] Unexpected value type received:", value, typeof value);
                        return NaN;
                    }
                }
            });

            // The 'values' in the update event are now formatted by format.to, so they are date strings.
            dateSliderElement.noUiSlider.on('update', function (values, handle) {
                // values should be an array of date strings like ["2023-01-15", "2023-08-20"]
                // console.log('Slider update event, values:', values); 
                if(startDateReadout) startDateReadout.textContent = values[0];
                if(endDateReadout) endDateReadout.textContent = values[1];
                if(hiddenFineTuneStart) hiddenFineTuneStart.value = values[0];
                if(hiddenFineTuneEnd) hiddenFineTuneEnd.value = values[1];
            });

            dateSliderElement.noUiSlider.on('update', function (values, handle) {
                // values is an array of strings from the 'to' formatter, e.g., ["2023-01-15", "2023-08-20"]
                if(startDateReadout) startDateReadout.textContent = values[0];
                if(endDateReadout) endDateReadout.textContent = values[1];
                if(hiddenFineTuneStart) hiddenFineTuneStart.value = values[0];
                if(hiddenFineTuneEnd) hiddenFineTuneEnd.value = values[1];
            });
            
            // Set initial readout values correctly
            if(startDateReadout) startDateReadout.textContent = currentFineTuneStartStr;
            if(endDateReadout) endDateReadout.textContent = currentFineTuneEndStr;


            // Client-side validation for overall date pickers
            const startDateInputHTML = document.getElementById('start_date'); // Renamed to avoid conflict
            const endDateInputHTML = document.getElementById('end_date');     // Renamed
            if(startDateInputHTML && endDateInputHTML) {
                startDateInputHTML.addEventListener('change', () => {
                    if (startDateInputHTML.value) endDateInputHTML.min = startDateInputHTML.value;
                });
                endDateInputHTML.addEventListener('change', () => {
                    if (endDateInputHTML.value) startDateInputHTML.max = endDateInputHTML.value;
                });
                if (startDateInputHTML.value) endDateInputHTML.min = startDateInputHTML.value;
                if (endDateInputHTML.value) startDateInputHTML.max = endDateInputHTML.value;
            }
        });
    </script>
</body>
</html>